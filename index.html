<!doctype html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>PDF Viewer (minimal)</title>
    <link
      rel="stylesheet"
      href="./node_modules/pdfjs-dist/web/pdf_viewer.css"
    />
    <style>
      :root {
        --inset-y: 0px; /* top & bottom inset INSIDE the scroll area */
        --side-margin: 0px; /* left/right margin around pages */
        --page-gap: 64px; /* vertical gap between pages */
        --bg: #181616;
        --page-radius: 8px;
      }
      * {
        box-sizing: border-box;
      }
      html,
      body {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
        overflow: hidden;
        background: transparent;
        -webkit-user-select: none;
      }
      #viewerContainer {
        position: fixed;
        inset: 0;
        overflow: auto;
        padding: var(--inset-y) var(--side-margin);
        background: var(--bg);
        overscroll-behavior-y: contain;
        scrollbar-gutter: stable both-edges;
        -webkit-overflow-scrolling: touch;
        scrollbar-width: none;
      }
      #viewerContainer::-webkit-scrollbar {
        width: 0;
        height: 0;
        display: none;
      }
      #viewer {
        background: var(--bg) !important;
      }
      .pdfViewer .page,
      .pdfViewer .page .canvasWrapper,
      .pdfViewer .page canvas,
      .pdfViewer .page .textLayer,
      .pdfViewer .page .annotationLayer {
        border-radius: var(--page-radius);
      }
      .pdfViewer .page {
        margin: 0 auto var(--page-gap) auto !important;
        box-shadow: none !important;
        border: none !important;
        background: #fff;
        border-radius: 8px;
        overflow: hidden;
      }
      false [class*="toolbar"],
      [id*="toolbar"],
      #secondaryToolbar,
      #overlayContainer,
      #sidebarContainer {
        display: none !important;
      }
    </style>
  </head>
  <body>
    <div id="viewerContainer" tabindex="0" aria-label="PDF Viewer">
      <div id="viewer" class="pdfViewer"></div>
    </div>

    <script>
      if (!Promise.withResolvers) {
        Promise.withResolvers = function () {
          let resolve, reject;
          const promise = new Promise((res, rej) => {
            resolve = res;
            reject = rej;
          });
          return { promise, resolve, reject };
        };
      }
    </script>

    <script type="module">
      import * as pdfjsLib from "./node_modules/pdfjs-dist/build/pdf.mjs";
      import * as pdfjsViewer from "./node_modules/pdfjs-dist/web/pdf_viewer.mjs";

      pdfjsLib.GlobalWorkerOptions.workerSrc = new URL(
        "./node_modules/pdfjs-dist/build/pdf.worker.mjs",
        import.meta.url,
      ).toString();

      const container = document.getElementById("viewerContainer");
      const viewerEl = document.getElementById("viewer");

      const { ipcRenderer } = window.electron;

      const eventBus = new pdfjsViewer.EventBus();
      const linkService = new pdfjsViewer.PDFLinkService({ eventBus });

      const pdfViewer = new pdfjsViewer.PDFViewer({
        container,
        viewer: viewerEl,
        eventBus,
        linkService,
        useOnlyCssZoom: false,
        textLayerMode: 2,
        annotationMode: 2,
        enableScripting: false,
        l10n: pdfjsViewer.NullL10n,
      });
      linkService.setViewer(pdfViewer);

      ipcRenderer.on("viewer-config", (cfg) => {
        if (typeof cfg?.insetY === "number")
          document.documentElement.style.setProperty(
            "--inset-y",
            `${cfg.insetY}px`,
          );
        if (typeof cfg?.sideMargin === "number")
          document.documentElement.style.setProperty(
            "--side-margin",
            `${cfg.sideMargin}px`,
          );
        if (typeof cfg?.pageGap === "number")
          document.documentElement.style.setProperty(
            "--page-gap",
            `${cfg.pageGap}px`,
          );
        if (typeof cfg?.pageRadius === "number")
          document.documentElement.style.setProperty(
            "--page-radius",
            `${cfg.pageRadius}px`,
          );
      });

      async function openPdf(localPath) {
        if (typeof localPath !== "string" || !localPath.trim()) {
          console.warn("[pdfview] openPdf called without a path");
          return;
        }
        const p = localPath.trim().replace(/\\/g, "/");
        const url = p.startsWith("file://") ? p : `file://${p}`;

        const loadingTask = pdfjsLib.getDocument({
          url,
          cMapUrl: new URL(
            "./node_modules/pdfjs-dist/cmaps/",
            import.meta.url,
          ).toString(),
          cMapPacked: true,
          standardFontDataUrl: new URL(
            "./node_modules/pdfjs-dist/standard_fonts/",
            import.meta.url,
          ).toString(),
        });

        const pdfDocument = await loadingTask.promise;
        pdfViewer.setDocument(pdfDocument);
        linkService.setDocument(pdfDocument, null);
      }

      ipcRenderer.on("load-pdf", (pdfPath) => openPdf(pdfPath));
      ipcRenderer.on("reload-pdf", (pdfPath) => {
        if (!pdfPath) return;
        const scrollTop = container.scrollTop;
        openPdf(pdfPath).then(() => {
          container.scrollTop = scrollTop;
        });
      });

      const MIN_SCALE = 0.4;
      const MAX_SCALE = 6;
      const ZOOM_INTENSITY = 0.02;

      let pinchActive = false;
      let committedScale = 1;
      let cssScale = 1;
      let wheelAccum = 0;
      let wheelRAF = 0;
      let pinchEndTimer = 0;
      let lastPointer = { x: 0, y: 0 };

      function beginPinch() {
        if (pinchActive) return;
        pinchActive = true;
        committedScale = pdfViewer.currentScale || 1;
        cssScale = committedScale;
        viewerEl.style.willChange = "transform";
      }

      function endPinch() {
        if (!pinchActive) return;
        pinchActive = false;

        // Compute the exact target scroll to keep the point under the cursor
        // fixed when transitioning from CSS-zoomed layout -> re-rendered layout.
        const targetScale = cssScale || pdfViewer.currentScale || 1;
        const rect = container.getBoundingClientRect();
        const dx = lastPointer.x - rect.left;
        const dy = lastPointer.y - rect.top;
        const px = container.scrollLeft + dx; // content-space coords under pointer
        const py = container.scrollTop + dy;
        const k = targetScale / (committedScale || 1);
        const targetScrollLeft = px * k - dx;
        const targetScrollTop = py * k - dy;

        // 1) Trigger the real pdf.js scale (layout + re-render) **while**
        //    the CSS transform is still applied to avoid a visible jump.
        pdfViewer.useOnlyCssZoom = false;
        pdfViewer.currentScale = targetScale;
        container.scrollLeft = targetScrollLeft;
        container.scrollTop = targetScrollTop;

        // 2) On the next frames, drop the temp CSS transform and re-apply
        //    the same scroll once layout has settled. This eliminates the
        //    tiny "snap" at the end of the gesture.
        requestAnimationFrame(() => {
          viewerEl.style.transform = "";
          viewerEl.style.transformOrigin = "";
          viewerEl.style.willChange = "";
          requestAnimationFrame(() => {
            container.scrollLeft = targetScrollLeft;
            container.scrollTop = targetScrollTop;
          });
        });
      }
      function clamp(v, a, b) {
        return Math.max(a, Math.min(b, v));
      }

      function setScaleKeepingPointer(cx, cy, newScale) {
        const prev = pdfViewer.currentScale || 1;
        if (newScale === prev) return;
        const rect = container.getBoundingClientRect();
        const px = container.scrollLeft + (cx - rect.left);
        const py = container.scrollTop + (cy - rect.top);
        const k = newScale / prev;
        pdfViewer.currentScale = newScale;
        requestAnimationFrame(() => {
          container.scrollLeft = px * k - (cx - rect.left);
          container.scrollTop = py * k - (cy - rect.top);
        });
      }

      container.addEventListener(
        "wheel",
        (e) => {
          const isZoomGesture = e.ctrlKey || e.metaKey;
          if (!isZoomGesture) return;
          e.preventDefault();

          beginPinch();

          const unit = e.deltaMode === 1 ? 16 : e.deltaMode === 2 ? 800 : 1;
          wheelAccum += e.deltaY * unit;
          lastPointer.x = e.clientX;
          lastPointer.y = e.clientY;

          if (!wheelRAF) {
            wheelRAF = requestAnimationFrame(() => {
              const factor = Math.exp(-wheelAccum * ZOOM_INTENSITY);
              const target = clamp(
                (cssScale || committedScale) * factor,
                MIN_SCALE,
                MAX_SCALE,
              );

              const rect = container.getBoundingClientRect();
              const originX =
                container.scrollLeft + (lastPointer.x - rect.left);
              const originY = container.scrollTop + (lastPointer.y - rect.top);
              const cssMultiplier = target / committedScale;
              viewerEl.style.transformOrigin = `${originX}px ${originY}px`;
              viewerEl.style.transform = `scale(${cssMultiplier})`;
              cssScale = target;

              wheelAccum = 0;
              wheelRAF = 0;
            });
          }

          clearTimeout(pinchEndTimer);
          pinchEndTimer = setTimeout(endPinch, 120);
        },
        { passive: false },
      );
      document.addEventListener("keydown", (e) => {
        const mod = e.metaKey || e.ctrlKey;
        if (!mod) return;
        const rect = container.getBoundingClientRect();
        const cx = rect.left + rect.width / 2;
        const cy = rect.top + rect.height / 2;
        if (e.key === "=" || e.key === "+") {
          e.preventDefault();
          setScaleKeepingPointer(
            cx,
            cy,
            clamp((pdfViewer.currentScale || 1) * 1.1, MIN_SCALE, MAX_SCALE),
          );
        } else if (e.key === "-") {
          e.preventDefault();
          setScaleKeepingPointer(
            cx,
            cy,
            clamp((pdfViewer.currentScale || 1) / 1.1, MIN_SCALE, MAX_SCALE),
          );
        } else if (e.key === "0") {
          e.preventDefault();
          setScaleKeepingPointer(cx, cy, 1);
        }
      });

      document.addEventListener("keydown", (e) => {
        if (
          ((e.metaKey || e.ctrlKey) && e.key.toLowerCase() === "q") ||
          e.key === "Escape"
        ) {
          ipcRenderer.send("close-window");
        }
      });
    </script>
  </body>
</html>
